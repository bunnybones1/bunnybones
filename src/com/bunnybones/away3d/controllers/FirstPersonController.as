package com.bunnybones.away3d.controllers{	import away3d.arcane;	import away3d.controllers.ControllerBase;	import away3d.core.math.*;	import away3d.entities.*;	import awayphysics.dynamics.AWPRigidBody;	import flash.geom.Vector3D;		use namespace arcane;		/**	 * Extended camera used to hover round a specified target object.	 * 	 * @see	away3d.containers.View3D	 */	public class FirstPersonController extends ControllerBase	{		private var awpBody:AWPRigidBody;				protected var forceHeight:Number;		protected var _walkIncrement:Number = 0;		protected var _strafeIncrement:Number = 0;		protected var _ascendIncrement:Number = 0;		protected var _tiltIncrement:Number = 0;		protected var _panIncrement:Number = 0;		/**		 * Fractional step taken each time the <code>hover()</code> method is called. Defaults to 8.		 * 		 * Affects the speed at which the <code>tiltAngle</code> and <code>panAngle</code> resolve to their targets.		 * 		 * @see	#tiltAngle		 * @see	#panAngle		 */				/**		 * Creates a new <code>HoverController</code> object.		 */		public function FirstPersonController(targetObject:Entity = null, forceHeight:Number = NaN, awpBody:AWPRigidBody = null)		{			super(targetObject);			this.awpBody = awpBody;			this.forceHeight = forceHeight;		}				/**		 * Updates the current tilt angle and pan angle values.		 * 		 * Values are calculated using the defined <code>tiltAngle</code>, <code>panAngle</code> and <code>steps</code> variables.		 * 		 * @see	#tiltAngle		 * @see	#panAngle		 * @see	#steps		 */		public override function update():void		{			updateRotations();			updateMoves();		}				protected function updateRotations():void 		{			if (_tiltIncrement) {				targetObject.pitch(_tiltIncrement);				_tiltIncrement = 0;			}						if (_panIncrement) {				targetObject.yaw(_panIncrement);				_panIncrement = 0;			}		}				protected function updateMoves():void 		{			if (_walkIncrement) {				_targetObject.moveForward(_walkIncrement);				_walkIncrement = 0;			}						if (_strafeIncrement) {				targetObject.moveRight(_strafeIncrement);				_strafeIncrement = 0;			}						if (_ascendIncrement) {				targetObject.moveUp(_ascendIncrement);				_ascendIncrement = 0;			}						if (!isNaN(forceHeight)) _targetObject.y = forceHeight;		}				public function incrementWalk(val:Number):void		{			if (val == 0)				return;						_walkIncrement += val;						notifyUpdate();		}				public function incrementStrafe(val:Number):void		{			if (val == 0)				return;						_strafeIncrement += val;						notifyUpdate();		}				public function incrementAscend(val:Number):void		{			if (val == 0)				return;						_ascendIncrement += val;						notifyUpdate();		}				public function incrementTilt(val:Number):void		{			if (val == 0)				return;						_tiltIncrement += val;			notifyUpdate();		}				public function incrementPan(val:Number):void		{			if (val == 0)				return;						_panIncrement += val;			notifyUpdate();		}				public function set immediateWalk(value:Number):void		{			incrementWalk(value);		}				public function set immediateStrafe(value:Number):void		{			incrementStrafe(value);		}				public function set immediateAscend(value:Number):void		{			incrementAscend(value);		}				public function set immediateTilt(value:Number):void		{			incrementTilt(value);		}				public function set immediatePan(value:Number):void		{			incrementPan(value);		}	}}